package me.rerere.rikkahub.service

import android.util.Log
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.map
import me.rerere.rikkahub.data.db.entity.MemoryTable
import me.rerere.rikkahub.data.db.entity.MemoryTableRow
import me.rerere.rikkahub.data.model.MemoryTableRowItem
import me.rerere.rikkahub.data.repository.MemoryTableRepository
import java.io.StringReader
import java.io.StringWriter
import java.util.UUID

private const val TAG = "MemoryTableQueryService"

/**
 * 记忆表格查询服务
 * 提供结构化数据查询、格式化和导入/导出功能
 */
class MemoryTableQueryService(
    private val memoryTableRepository: MemoryTableRepository
) {
    private val csvParser = CSVParser()

    /**
     * 搜索结果数据类
     */
    data class MemoryTableSearchResult(
        val table: MemoryTable,
        val rows: List<MemoryTableRow>,
        val matchedColumns: List<String> = emptyList()
    )

    /**
     * 根据关键词搜索记忆表格
     */
    suspend fun searchTables(
        assistantId: String,
        query: String
    ): List<MemoryTableSearchResult> {
        if (query.isBlank()) {
            return emptyList()
        }

        val lowerQuery = query.lowercase()
        val tables = memoryTableRepository.getMemoryTablesByAssistant(assistantId).first()

        return tables.mapNotNull { table ->
            // 获取表格的所有行
            val rows = memoryTableRepository.getRowsByTableId(table.id).first()

            // 检查行数据是否匹配查询
            val matchedRows = rows.filter { row ->
                row.rowData.values.any { value ->
                    value.lowercase().contains(lowerQuery)
                }
            }

            if (matchedRows.isNotEmpty()) {
                // 找到匹配哪些列
                val matchedColumns = table.columnHeaders.filter { column ->
                    matchedRows.any { row ->
                        row.rowData[column]?.lowercase()?.contains(lowerQuery) == true
                    }
                }

                MemoryTableSearchResult(
                    table = table,
                    rows = matchedRows,
                    matchedColumns = matchedColumns
                )
            } else {
                null
            }
        }
    }

    /**
     * 将记忆表格数据格式化为Markdown表格
     */
    fun formatTableAsMarkdown(table: MemoryTable, rows: List<MemoryTableRow>): String {
        if (table.columnHeaders.isEmpty()) {
            return "Empty table: ${table.name}"
        }

        return buildString {
            // 表格标题
            appendLine("### ${table.name}")
            if (table.description.isNotBlank()) {
                appendLine()
                appendLine(table.description)
                appendLine()
            }

            // 构建Markdown表格
            appendLine("| ${table.columnHeaders.joinToString(" | ")} |")
            appendLine("| ${table.columnHeaders.map { "---" }.joinToString(" | ")} |")

            // 添加数据行
            rows.forEach { row ->
                val cellValues = table.columnHeaders.map { column ->
                    row.rowData[column] ?: ""
                }
                appendLine("| ${cellValues.joinToString(" | ")} |")
            }

            appendLine()
            appendLine("*Generated by RikkaHub Memory Table*")
        }
    }

    /**
     * 导出表格为CSV格式
     */
    fun exportTableAsCSV(table: MemoryTable, rows: List<MemoryTableRow>): String {
        if (table.columnHeaders.isEmpty()) {
            return ""
        }

        val writer = StringWriter()
        csvParser.writeCSV(writer, table.columnHeaders, rows.map { it.rowData })
        return writer.toString()
    }

    /**
     * 从CSV导入表格
     */
    suspend fun importTableFromCSV(
        assistantId: String,
        csvContent: String
    ): Result<MemoryTable> {
        return runCatching {
            if (csvContent.isBlank()) {
                throw IllegalArgumentException("CSV content is empty")
            }

            val reader = StringReader(csvContent)
            val (headers, dataRows) = csvParser.readCSV(reader)

            if (headers.isEmpty()) {
                throw IllegalArgumentException("No headers found in CSV")
            }

            if (dataRows.isEmpty()) {
                throw IllegalArgumentException("No data rows found in CSV")
            }

            // 创建表格
            val table = memoryTableRepository.addTable(
                assistantId = assistantId,
                name = "Imported Table ${System.currentTimeMillis()}",
                description = "Imported from CSV",
                columnHeaders = headers
            )

            // 添加数据行
            dataRows.forEach { rowData ->
                memoryTableRepository.addRow(
                    tableId = table.id,
                    rowData = rowData
                )
            }

            Log.d(TAG, "Successfully imported table ${table.name} with ${dataRows.size} rows")
            table
        }.onFailure { e ->
            Log.e(TAG, "Failed to import table from CSV", e)
        }
    }

    /**
     * 获取表格的详细搜索结果（用于AI工具调用）
     */
    suspend fun getTableForAI(
        tableId: String,
        query: String? = null
    ): Result<String> {
        return runCatching {
            val table = memoryTableRepository.getMemoryTableById(tableId)
                ?: throw IllegalArgumentException("Table not found: $tableId")

            val rows = memoryTableRepository.getRowsByTableId(tableId).first()

            val filteredRows = if (query.isNullOrBlank()) {
                rows
            } else {
                val lowerQuery = query.lowercase()
                rows.filter { row ->
                    row.rowData.values.any { value ->
                        value.lowercase().contains(lowerQuery)
                    }
                }
            }

            if (filteredRows.isEmpty()) {
                "No data found in table '${table.name}'${if (query != null) " matching query '$query'" else ""}"
            } else {
                formatTableAsMarkdown(table, filteredRows)
            }
        }.onFailure { e ->
            Log.e(TAG, "Failed to get table for AI", e)
        }
    }

    /**
     * CSV解析器内部类
     */
    private class CSVParser {
        /**
         * 读取CSV内容
         */
        fun readCSV(reader: StringReader): Pair<List<String>, List<Map<String, String>>> {
            val lines = reader.readText().split("\n", "\r\n").filter { it.isNotBlank() }
            if (lines.isEmpty()) {
                return emptyList() to emptyList()
            }

            // 解析标题行
            val headers = parseCSVLine(lines[0])
            if (headers.isEmpty()) {
                return emptyList() to emptyList()
            }

            // 解析数据行
            val dataRows = lines.drop(1).map { line ->
                val values = parseCSVLine(line)
                headers.mapIndexedNotNull { index, header ->
                    if (index < values.size) {
                        header to values[index]
                    } else {
                        null
                    }
                }.toMap()
            }

            return headers to dataRows
        }

        /**
         * 写入CSV内容
         */
        fun writeCSV(
            writer: StringWriter,
            headers: List<String>,
            rows: List<Map<String, String>>
        ) {
            // 写入标题
            writer.appendLine(formatCSVLine(headers))

            // 写入数据
            rows.forEach { row ->
                val values = headers.map { header -> row[header] ?: "" }
                writer.appendLine(formatCSVLine(values))
            }
        }

        /**
         * 解析CSV行（处理引号和逗号）
         */
        private fun parseCSVLine(line: String): List<String> {
            val result = mutableListOf<String>()
            var current = ""
            var inQuotes = false

            for (i in line.indices) {
                val char = line[i]

                when {
                    char == '"' -> {
                        if (inQuotes && i + 1 < line.length && line[i + 1] == '"') {
                            // 双引号转义
                            current += '"'
                            i++ // 跳过下一个引号
                        } else {
                            inQuotes = !inQuotes
                        }
                    }
                    char == ',' && !inQuotes -> {
                        result.add(current)
                        current = ""
                    }
                    else -> {
                        current += char
                    }
                }
            }

            result.add(current)
            return result
        }

        /**
         * 格式化CSV行
         */
        private fun formatCSVLine(values: List<String>): String {
            return values.map { value ->
                if (value.contains(',') || value.contains('"') || value.contains('\n')) {
                    "\"${value.replace("\"", "\"\"")}\""
                } else {
                    value
                }
            }.joinToString(",")
        }
    }
}
